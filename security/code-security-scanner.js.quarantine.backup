
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

class CodeSecurityScanner {
    constructor() {
        this.vulnerabilityPatterns = {
            CRITICAL: [
                // SQL Injection patterns
                /\$\{.*?SELECT.*?\}/gi,
                /\$\{.*?INSERT.*?\}/gi,
                /\$\{.*?UPDATE.*?\}/gi,
                /\$\{.*?DELETE.*?\}/gi,
                /\$\{.*?DROP.*?\}/gi,
                /query\s*\(\s*[^?]/gi,
                /execute\s*\(\s*[^?]/gi,
                
                // Command Injection
                /exec\s*\(\s*[^,]*?\$\{/gi,
                /system\s*\(\s*[^,]*?\$\{/gi,
                /shell_exec\s*\(\s*[^,]*?\$\{/gi,
                /passthru\s*\(\s*[^,]*?\$\{/gi,
                /eval\s*\(\s*[^,]*?\$\{/gi,
                
                // Path Traversal
                /\.\.\/.*\.\./gi,
                /\.\.\\.*\.\./gi,
                /file_get_contents\s*\(\s*[^,]*?\$\{/gi,
                /include\s*\(\s*[^,]*?\$\{/gi,
                /require\s*\(\s*[^,]*?\$\{/gi,
                
                // Deserialization vulnerabilities
                /unserialize\s*\(\s*[^,]*?\$\{/gi,
                /pickle\.loads\s*\(\s*[^,]*?\$\{/gi,
                /yaml\.load\s*\(\s*[^,]*?\$\{/gi,
                
                // Hardcoded secrets
                /password\s*=\s*["'][^"']{1,}/gi,
                /api_?key\s*=\s*["'][^"']{10,}/gi,
                /secret\s*=\s*["'][^"']{10,}/gi,
                /token\s*=\s*["'][^"']{20,}/gi,
                /private_?key\s*=\s*["'][^"']{20,}/gi,
                
                // Crypto vulnerabilities
                /md5\s*\(/gi,
                /sha1\s*\(/gi,
                /DES\s*\(/gi,
                /RC4\s*\(/gi,
                /ECB\s*mode/gi,
                
                // XSS vulnerabilities
                /innerHTML\s*=\s*[^"']*\$\{/gi,
                /outerHTML\s*=\s*[^"']*\$\{/gi,
                /document\.write\s*\(\s*[^"']*\$\{/gi,
                /dangerouslySetInnerHTML/gi,
                
                // CSRF vulnerabilities
                /\$_GET\[.*?\]/gi,
                /\$_POST\[.*?\]/gi,
                /\$_REQUEST\[.*?\]/gi,
                
                // LDAP Injection
                /ldap_search\s*\(\s*[^,]*?\$\{/gi,
                /ldap_bind\s*\(\s*[^,]*?\$\{/gi,
                
                // XXE vulnerabilities
                /simplexml_load_string\s*\(\s*[^,]*?\$\{/gi,
                /DOMDocument.*loadXML/gi,
                /<!ENTITY.*>/gi,
                
                // Quantum computing vulnerabilities
                /RSA.*1024/gi,
                /DSA.*1024/gi,
                /ECDSA.*P-256/gi,
                /DH.*1024/gi
            ],
            
            HIGH: [
                // Weak randomness
                /Math\.random\(\)/gi,
                /rand\(\)/gi,
                /mt_rand\(\)/gi,
                /srand\(\)/gi,
                
                // Information disclosure
                /phpinfo\(\)/gi,
                /var_dump\(\)/gi,
                /print_r\(\)/gi,
                /console\.log\(.*password/gi,
                /console\.log\(.*secret/gi,
                /console\.log\(.*token/gi,
                
                // Insecure redirects
                /header\s*\(\s*["']Location:/gi,
                /window\.location\s*=\s*[^"']*\$\{/gi,
                /window\.open\s*\(\s*[^"']*\$\{/gi,
                
                // Weak session management
                /session_id\(\)/gi,
                /session_regenerate_id\(\)/gi,
                /setcookie\(.*httponly.*false/gi,
                /setcookie\(.*secure.*false/gi,
                
                // File upload vulnerabilities
                /move_uploaded_file\(/gi,
                /\$_FILES\[/gi,
                /file_uploads.*on/gi,
                
                // Weak authentication
                /strcmp\(\)/gi,
                /strcasecmp\(\)/gi,
                /==.*password/gi,
                /==.*hash/gi,
                
                // Insecure communication
                /curl_setopt.*CURLOPT_SSL_VERIFYPEER.*false/gi,
                /curl_setopt.*CURLOPT_SSL_VERIFYHOST.*false/gi,
                /http:\/\//gi,
                
                // Race conditions
                /unlink\(\)/gi,
                /rmdir\(\)/gi,
                /file_exists\(\).*unlink\(\)/gi,
                
                // Buffer overflow patterns
                /strcpy\(/gi,
                /strcat\(/gi,
                /sprintf\(/gi,
                /gets\(/gi,
                
                // Memory leaks
                /malloc\(.*\).*return/gi,
                /new\s+.*\[.*\].*return/gi,
                
                // Blockchain specific vulnerabilities
                /tx\.origin/gi,
                /block\.timestamp/gi,
                /block\.number/gi,
                /selfdestruct\(/gi,
                /suicide\(/gi,
                /delegatecall\(/gi,
                /call\.value\(/gi,
                
                // Smart contract vulnerabilities
                /transfer\(.*\).*require/gi,
                /send\(.*\).*require/gi,
                /call\(.*\).*require/gi,
                /\.call\./gi,
                /\.delegatecall\./gi,
                /msg\.sender.*==.*owner/gi,
                /onlyOwner/gi,
                
                // DeFi specific vulnerabilities
                /flashloan/gi,
                /oracle.*price/gi,
                /slippage.*0/gi,
                /deadline.*0/gi,
                /amount.*max/gi,
                
                // Exchange vulnerabilities
                /order.*amount.*0/gi,
                /balance.*subtract.*order/gi,
                /withdraw.*amount.*balance/gi,
                /transfer.*amount.*fee/gi
            ],
            
            MEDIUM: [
                // Information leakage
                /error_reporting\(E_ALL\)/gi,
                /display_errors.*on/gi,
                /log_errors.*off/gi,
                /expose_php.*on/gi,
                
                // Weak configurations
                /allow_url_include.*on/gi,
                /allow_url_fopen.*on/gi,
                /register_globals.*on/gi,
                /magic_quotes.*on/gi,
                
                // Deprecated functions
                /mysql_query\(/gi,
                /mysql_connect\(/gi,
                /ereg\(/gi,
                /split\(/gi,
                /create_function\(/gi,
                
                // Missing input validation
                /\$_GET.*\[.*\].*echo/gi,
                /\$_POST.*\[.*\].*echo/gi,
                /\$_COOKIE.*\[.*\].*echo/gi,
                /\$_SERVER.*\[.*\].*echo/gi,
                
                // Missing output encoding
                /echo.*\$_/gi,
                /print.*\$_/gi,
                /printf.*\$_/gi,
                
                // Insecure file operations
                /fopen\(.*["']w/gi,
                /file_put_contents\(/gi,
                /fputs\(/gi,
                /fwrite\(/gi,
                
                // Missing CSRF protection
                /form.*method.*post/gi,
                /input.*type.*hidden.*name.*csrf/gi,
                
                // Weak password policies
                /strlen\(.*password.*\).*<.*8/gi,
                /password.*length.*<.*8/gi,
                
                // Missing rate limiting
                /login.*attempt/gi,
                /password.*reset/gi,
                /api.*endpoint/gi,
                
                // Insecure headers
                /X-Frame-Options/gi,
                /X-Content-Type-Options/gi,
                /X-XSS-Protection/gi,
                /Strict-Transport-Security/gi
            ]
        };
        
        this.scanResults = new Map();
        this.quarantinedFiles = new Set();
        this.securityMetrics = {
            filesScanned: 0,
            vulnerabilitiesFound: 0,
            criticalIssues: 0,
            highRiskIssues: 0,
            mediumRiskIssues: 0,
            lastScan: Date.now()
        };
        
        this.whitelistedPatterns = [
            // Allow legitimate uses
            /console\.log\(.*debug/gi,
            /console\.log\(.*info/gi,
            /console\.log\(.*trace/gi,
            // Add more whitelist patterns as needed
        ];
        
        this.quantumSafePatterns = [
            /kyber/gi,
            /dilithium/gi,
            /sphincs/gi,
            /falcon/gi,
            /aes-256-gcm/gi,
            /sha3-512/gi,
            /blake2b/gi,
            /argon2/gi,
            /scrypt/gi,
            /bcrypt/gi
        ];
        
        console.log('🔍 Code Security Scanner Initialized');
    }

    async scanDirectory(directoryPath) {
        console.log(`🔍 Starting comprehensive security scan of: ${directoryPath}`);
        
        const files = await this.getAllFiles(directoryPath);
        const scanPromises = files.map(file => this.scanFile(file));
        
        await Promise.all(scanPromises);
        
        this.generateSecurityReport();
        return this.scanResults;
    }

    async getAllFiles(dir, files = []) {
        const items = fs.readdirSync(dir);
        
        for (const item of items) {
            const fullPath = path.join(dir, item);
            const stat = fs.statSync(fullPath);
            
            if (stat.isDirectory()) {
                // Skip node_modules and other non-essential directories
                if (!['node_modules', '.git', '.npm', 'dist', 'build'].includes(item)) {
                    await this.getAllFiles(fullPath, files);
                }
            } else if (this.shouldScanFile(fullPath)) {
                files.push(fullPath);
            }
        }
        
        return files;
    }

    shouldScanFile(filePath) {
        const extensionsToScan = [
            '.js', '.ts', '.jsx', '.tsx', '.py', '.php', '.java', '.cs', '.cpp', '.c',
            '.go', '.rs', '.rb', '.sol', '.vy', '.move', '.cairo', '.fe', '.yul',
            '.html', '.htm', '.xml', '.json', '.yml', '.yaml', '.toml', '.ini',
            '.sh', '.bat', '.ps1', '.sql', '.md', '.txt'
        ];
        
        const ext = path.extname(filePath).toLowerCase();
        return extensionsToScan.includes(ext);
    }

    async scanFile(filePath) {
        try {
            const content = fs.readFileSync(filePath, 'utf-8');
            const vulnerabilities = this.detectVulnerabilities(content, filePath);
            
            if (vulnerabilities.length > 0) {
                this.scanResults.set(filePath, vulnerabilities);
                
                // Check if file should be quarantined
                const criticalVulns = vulnerabilities.filter(v => v.severity === 'CRITICAL');
                if (criticalVulns.length > 0) {
                    this.quarantineFile(filePath, criticalVulns);
                }
            }
            
            this.securityMetrics.filesScanned++;
            this.securityMetrics.vulnerabilitiesFound += vulnerabilities.length;
            
            // Update severity counters
            vulnerabilities.forEach(vuln => {
                switch (vuln.severity) {
                    case 'CRITICAL':
                        this.securityMetrics.criticalIssues++;
                        break;
                    case 'HIGH':
                        this.securityMetrics.highRiskIssues++;
                        break;
                    case 'MEDIUM':
                        this.securityMetrics.mediumRiskIssues++;
                        break;
                }
            });
            
        } catch (error) {
            console.error(`Error scanning file ${filePath}:`, error.message);
        }
    }

    detectVulnerabilities(content, filePath) {
        const vulnerabilities = [];
        const lines = content.split('\n');
        
        Object.entries(this.vulnerabilityPatterns).forEach(([severity, patterns]) => {
            patterns.forEach((pattern, patternIndex) => {
                lines.forEach((line, lineNumber) => {
                    const matches = line.match(pattern);
                    if (matches && !this.isWhitelisted(line)) {
                        matches.forEach(match => {
                            vulnerabilities.push({
                                severity,
                                pattern: pattern.source,
                                match: match.trim(),
                                line: lineNumber + 1,
                                content: line.trim(),
                                file: filePath,
                                patternId: `${severity}_${patternIndex}`,
                                timestamp: Date.now(),
                                quantumSafe: this.isQuantumSafe(line)
                            });
                        });
                    }
                });
            });
        });
        
        return vulnerabilities;
    }

    isWhitelisted(line) {
        return this.whitelistedPatterns.some(pattern => pattern.test(line));
    }

    isQuantumSafe(line) {
        return this.quantumSafePatterns.some(pattern => pattern.test(line));
    }

    quarantineFile(filePath, criticalVulnerabilities) {
        console.log(`🚨 QUARANTINING FILE: ${filePath}`);
        console.log('Critical vulnerabilities found:', criticalVulnerabilities.length);
        
        this.quarantinedFiles.add(filePath);
        
        // Create backup
        const backupPath = `${filePath}.quarantine.backup`;
        fs.copyFileSync(filePath, backupPath);
        
        // Create quarantine notice
        const notice = `
/*
 * ⚠️  SECURITY QUARANTINE NOTICE ⚠️ 
 * 
 * This file has been quarantined due to critical security vulnerabilities.
 * Original file backed up as: ${path.basename(backupPath)}
 * 
 * Critical Issues Found:
${criticalVulnerabilities.map(v => ` * Line ${v.line}: ${v.pattern} - ${v.match}`).join('\n')}
 * 
 * Quarantine Time: ${new Date().toISOString()}
 * Scanner: Quantora Advanced Security Scanner
 * 
 * DO NOT USE THIS FILE IN PRODUCTION UNTIL ISSUES ARE RESOLVED
 */

// File quarantined - see backup for original content
throw new Error('SECURITY: File quarantined due to critical vulnerabilities');
`;
        
        fs.writeFileSync(filePath, notice);
    }

    generateSecurityReport() {
        const report = {
            scanSummary: {
                ...this.securityMetrics,
                scanDuration: Date.now() - this.securityMetrics.lastScan,
                quarantinedFiles: this.quarantinedFiles.size
            },
            vulnerabilityBreakdown: this.getVulnerabilityBreakdown(),
            criticalFindings: this.getCriticalFindings(),
            quarantinedFiles: Array.from(this.quarantinedFiles),
            recommendations: this.generateRecommendations(),
            quantumReadiness: this.assessQuantumReadiness(),
            complianceStatus: this.assessComplianceStatus()
        };
        
        // Save report
        const reportPath = `security_scan_report_${Date.now()}.json`;
        fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
        
        console.log('🛡️ Security Scan Complete!');
        console.log(`📊 Files Scanned: ${this.securityMetrics.filesScanned}`);
        console.log(`🚨 Critical Issues: ${this.securityMetrics.criticalIssues}`);
        console.log(`⚠️  High Risk Issues: ${this.securityMetrics.highRiskIssues}`);
        console.log(`📋 Medium Risk Issues: ${this.securityMetrics.mediumRiskIssues}`);
        console.log(`🔒 Files Quarantined: ${this.quarantinedFiles.size}`);
        console.log(`📄 Report saved: ${reportPath}`);
        
        if (this.securityMetrics.criticalIssues > 0) {
            console.log('🚨 CRITICAL SECURITY ISSUES DETECTED - IMMEDIATE ACTION REQUIRED!');
        }
        
        return report;
    }

    getVulnerabilityBreakdown() {
        const breakdown = {};
        
        this.scanResults.forEach(vulnerabilities => {
            vulnerabilities.forEach(vuln => {
                const key = `${vuln.severity}_${vuln.pattern}`;
                breakdown[key] = (breakdown[key] || 0) + 1;
            });
        });
        
        return breakdown;
    }

    getCriticalFindings() {
        const critical = [];
        
        this.scanResults.forEach((vulnerabilities, filePath) => {
            vulnerabilities
                .filter(v => v.severity === 'CRITICAL')
                .forEach(vuln => {
                    critical.push({
                        file: filePath,
                        line: vuln.line,
                        vulnerability: vuln.pattern,
                        match: vuln.match,
                        quantumSafe: vuln.quantumSafe
                    });
                });
        });
        
        return critical.sort((a, b) => !a.quantumSafe - !b.quantumSafe);
    }

    generateRecommendations() {
        const recommendations = [];
        
        if (this.securityMetrics.criticalIssues > 0) {
            recommendations.push({
                priority: 'CRITICAL',
                category: 'IMMEDIATE_ACTION',
                description: 'Critical security vulnerabilities detected',
                action: 'Review and fix all quarantined files immediately'
            });
        }
        
        if (this.securityMetrics.highRiskIssues > 5) {
            recommendations.push({
                priority: 'HIGH',
                category: 'SECURITY_REVIEW',
                description: 'Multiple high-risk vulnerabilities found',
                action: 'Conduct comprehensive security code review'
            });
        }
        
        // Check for quantum readiness
        const quantumVulns = this.getQuantumVulnerabilities();
        if (quantumVulns > 0) {
            recommendations.push({
                priority: 'HIGH',
                category: 'QUANTUM_SECURITY',
                description: 'Non-quantum-safe cryptography detected',
                action: 'Upgrade to quantum-resistant algorithms'
            });
        }
        
        recommendations.push({
            priority: 'MEDIUM',
            category: 'CONTINUOUS_MONITORING',
            description: 'Implement automated security scanning',
            action: 'Set up regular security scans in CI/CD pipeline'
        });
        
        return recommendations;
    }

    getQuantumVulnerabilities() {
        let count = 0;
        this.scanResults.forEach(vulnerabilities => {
            count += vulnerabilities.filter(v => !v.quantumSafe).length;
        });
        return count;
    }

    assessQuantumReadiness() {
        const totalVulns = this.securityMetrics.vulnerabilitiesFound;
        const quantumVulns = this.getQuantumVulnerabilities();
        const quantumSafeRatio = totalVulns > 0 ? (totalVulns - quantumVulns) / totalVulns : 1;
        
        return {
            quantumSafeRatio,
            quantumVulnerabilities: quantumVulns,
            status: quantumSafeRatio > 0.9 ? 'EXCELLENT' : 
                   quantumSafeRatio > 0.7 ? 'GOOD' : 
                   quantumSafeRatio > 0.5 ? 'FAIR' : 'POOR',
            recommendation: quantumSafeRatio < 0.9 ? 'Upgrade to quantum-resistant cryptography' : 'Quantum readiness is good'
        };
    }

    assessComplianceStatus() {
        const criticalIssues = this.securityMetrics.criticalIssues;
        const highRiskIssues = this.securityMetrics.highRiskIssues;
        
        return {
            pciCompliant: criticalIssues === 0 && highRiskIssues < 5,
            soxCompliant: criticalIssues === 0,
            gdprCompliant: this.checkGDPRCompliance(),
            iso27001Compliant: criticalIssues === 0 && highRiskIssues < 3,
            overallCompliance: criticalIssues === 0 && highRiskIssues < 3 ? 'COMPLIANT' : 'NON_COMPLIANT'
        };
    }

    checkGDPRCompliance() {
        // Check for data privacy issues
        let gdprIssues = 0;
        
        this.scanResults.forEach(vulnerabilities => {
            vulnerabilities.forEach(vuln => {
                if (vuln.pattern.includes('personal_data') || 
                    vuln.pattern.includes('user_data') ||
                    vuln.pattern.includes('privacy')) {
                    gdprIssues++;
                }
            });
        });
        
        return gdprIssues === 0;
    }

    // Emergency response for critical vulnerabilities
    activateEmergencyResponse() {
        if (this.securityMetrics.criticalIssues > 0) {
            console.log('🚨 ACTIVATING EMERGENCY SECURITY RESPONSE');
            
            // Lock down critical systems
            this.lockdownCriticalSystems();
            
            // Notify security team
            this.notifySecurityTeam();
            
            // Generate emergency report
            this.generateEmergencyReport();
            
            // Activate incident response
            this.activateIncidentResponse();
        }
    }

    lockdownCriticalSystems() {
        console.log('🔒 LOCKING DOWN CRITICAL SYSTEMS');
        // Implementation would lock down critical systems
    }

    notifySecurityTeam() {
        console.log('📢 NOTIFYING SECURITY TEAM');
        // Implementation would send alerts to security team
    }

    generateEmergencyReport() {
        const emergencyReport = {
            timestamp: Date.now(),
            severity: 'EMERGENCY',
            criticalIssues: this.securityMetrics.criticalIssues,
            quarantinedFiles: Array.from(this.quarantinedFiles),
            immediateActions: this.getImmediateActions()
        };
        
        fs.writeFileSync(`EMERGENCY_SECURITY_REPORT_${Date.now()}.json`, 
                        JSON.stringify(emergencyReport, null, 2));
    }

    getImmediateActions() {
        return [
            'Stop all non-essential services',
            'Review all quarantined files',
            'Update all security patches',
            'Rotate all cryptographic keys',
            'Enable maximum security monitoring',
            'Conduct emergency security audit'
        ];
    }

    activateIncidentResponse() {
        console.log('🚨 INCIDENT RESPONSE ACTIVATED');
        // Implementation would follow incident response procedures
    }
}

// Execute comprehensive security scan if run directly
if (require.main === module) {
    const scanner = new CodeSecurityScanner();
    console.log('🔍 Starting Comprehensive Security Audit...');
    
    scanner.scanDirectory('./')
        .then(results => {
            console.log('\n🛡️ SECURITY AUDIT COMPLETE');
            
            if (scanner.securityMetrics.criticalIssues > 0) {
                console.log('🚨 CRITICAL SECURITY ISSUES DETECTED!');
                scanner.activateEmergencyResponse();
            } else if (scanner.securityMetrics.highRiskIssues > 0) {
                console.log('⚠️ HIGH RISK ISSUES DETECTED');
            } else {
                console.log('✅ NO CRITICAL VULNERABILITIES FOUND');
            }
            
            return scanner.generateSecurityReport();
        })
        .catch(error => {
            console.error('❌ Security scan failed:', error);
        });
}

module.exports = CodeSecurityScanner;
