
const fs = require('fs');
const path = require('path');

class VulnerabilityChecker {
    constructor() {
        this.vulnerabilities = [];
        this.errors = [];
        this.warnings = [];
        
        this.criticalPatterns = [
            // SQL Injection
            { pattern: /\$\{.*?(SELECT|INSERT|UPDATE|DELETE|DROP).*?\}/gi, type: 'SQL_INJECTION', severity: 'CRITICAL' },
            
            // Command Injection
            { pattern: /exec\s*\(\s*[^,]*?\$\{/gi, type: 'COMMAND_INJECTION', severity: 'CRITICAL' },
            { pattern: /system\s*\(\s*[^,]*?\$\{/gi, type: 'COMMAND_INJECTION', severity: 'CRITICAL' },
            
            // XSS Vulnerabilities
            { pattern: /innerHTML\s*=\s*[^"']*\$\{/gi, type: 'XSS', severity: 'HIGH' },
            { pattern: /dangerouslySetInnerHTML/gi, type: 'XSS', severity: 'HIGH' },
            
            // Hardcoded Secrets
            { pattern: /password\s*=\s*["'][^"']{1,}/gi, type: 'HARDCODED_SECRET', severity: 'CRITICAL' },
            { pattern: /api_?key\s*=\s*["'][^"']{10,}/gi, type: 'HARDCODED_SECRET', severity: 'CRITICAL' },
            { pattern: /secret\s*=\s*["'][^"']{10,}/gi, type: 'HARDCODED_SECRET', severity: 'CRITICAL' },
            
            // Weak Cryptography
            { pattern: /md5\s*\(/gi, type: 'WEAK_CRYPTO', severity: 'HIGH' },
            { pattern: /sha1\s*\(/gi, type: 'WEAK_CRYPTO', severity: 'HIGH' },
            
            // Path Traversal
            { pattern: /\.\.\/.*\.\./gi, type: 'PATH_TRAVERSAL', severity: 'HIGH' },
            
            // Unsafe Eval
            { pattern: /eval\s*\(/gi, type: 'CODE_INJECTION', severity: 'CRITICAL' },
            
            // Blockchain Specific
            { pattern: /tx\.origin/gi, type: 'BLOCKCHAIN_VULN', severity: 'HIGH' },
            { pattern: /block\.timestamp/gi, type: 'BLOCKCHAIN_VULN', severity: 'MEDIUM' },
            
            // Quantum Vulnerabilities
            { pattern: /RSA.*1024/gi, type: 'QUANTUM_VULN', severity: 'CRITICAL' },
            { pattern: /ECDSA.*P-256/gi, type: 'QUANTUM_VULN', severity: 'HIGH' }
        ];
        
        this.codeQualityPatterns = [
            // Error Handling
            { pattern: /catch\s*\(\s*\w+\s*\)\s*\{\s*\}/g, type: 'EMPTY_CATCH', severity: 'MEDIUM' },
            { pattern: /console\.log\(.*password/gi, type: 'INFO_LEAK', severity: 'HIGH' },
            { pattern: /console\.log\(.*secret/gi, type: 'INFO_LEAK', severity: 'HIGH' },
            
            // Memory Leaks
            { pattern: /setInterval\(/g, type: 'POTENTIAL_MEMORY_LEAK', severity: 'LOW' },
            { pattern: /setTimeout\(/g, type: 'POTENTIAL_MEMORY_LEAK', severity: 'LOW' },
            
            // Deprecated Functions
            { pattern: /unescape\(/gi, type: 'DEPRECATED', severity: 'MEDIUM' },
            { pattern: /escape\(/gi, type: 'DEPRECATED', severity: 'MEDIUM' }
        ];
    }

    async scanProject() {
        console.log('🔍 Starting comprehensive vulnerability scan...');
        
        const files = await this.getAllFiles('./');
        
        for (const file of files) {
            await this.scanFile(file);
        }
        
        this.generateReport();
        return {
            vulnerabilities: this.vulnerabilities,
            errors: this.errors,
            warnings: this.warnings
        };
    }

    async getAllFiles(dir, files = []) {
        try {
            const items = fs.readdirSync(dir);
            
            for (const item of items) {
                const fullPath = path.join(dir, item);
                const stat = fs.statSync(fullPath);
                
                if (stat.isDirectory()) {
                    if (!['node_modules', '.git', '.npm', 'dist', 'build'].includes(item)) {
                        await this.getAllFiles(fullPath, files);
                    }
                } else if (this.shouldScanFile(fullPath)) {
                    files.push(fullPath);
                }
            }
        } catch (error) {
            this.errors.push({
                file: dir,
                error: `Cannot read directory: ${error.message}`,
                type: 'FILE_ACCESS_ERROR'
            });
        }
        
        return files;
    }

    shouldScanFile(filePath) {
        const extensionsToScan = [
            '.js', '.ts', '.jsx', '.tsx', '.json', '.sol', '.vy'
        ];
        
        const ext = path.extname(filePath).toLowerCase();
        return extensionsToScan.includes(ext);
    }

    async scanFile(filePath) {
        try {
            const content = fs.readFileSync(filePath, 'utf-8');
            const lines = content.split('\n');
            
            // Check for syntax errors
            this.checkSyntaxErrors(filePath, content);
            
            // Check for vulnerabilities
            this.checkVulnerabilities(filePath, content, lines);
            
            // Check code quality
            this.checkCodeQuality(filePath, content, lines);
            
            // Check blockchain specific issues
            this.checkBlockchainSecurity(filePath, content, lines);
            
            // Check quantum resistance
            this.checkQuantumResistance(filePath, content, lines);
            
        } catch (error) {
            this.errors.push({
                file: filePath,
                error: error.message,
                type: 'FILE_READ_ERROR'
            });
        }
    }

    checkSyntaxErrors(filePath, content) {
        if (filePath.endsWith('.js') || filePath.endsWith('.ts')) {
            try {
                // Basic syntax checks
                if (content.includes('function') && !content.includes('{')) {
                    this.errors.push({
                        file: filePath,
                        error: 'Potential syntax error: function without opening brace',
                        type: 'SYNTAX_ERROR'
                    });
                }
                
                // Check for unmatched braces
                const openBraces = (content.match(/\{/g) || []).length;
                const closeBraces = (content.match(/\}/g) || []).length;
                
                if (openBraces !== closeBraces) {
                    this.errors.push({
                        file: filePath,
                        error: `Unmatched braces: ${openBraces} open, ${closeBraces} close`,
                        type: 'SYNTAX_ERROR'
                    });
                }
                
                // Check for unmatched parentheses
                const openParens = (content.match(/\(/g) || []).length;
                const closeParens = (content.match(/\)/g) || []).length;
                
                if (openParens !== closeParens) {
                    this.errors.push({
                        file: filePath,
                        error: `Unmatched parentheses: ${openParens} open, ${closeParens} close`,
                        type: 'SYNTAX_ERROR'
                    });
                }
                
            } catch (error) {
                this.errors.push({
                    file: filePath,
                    error: `Syntax check failed: ${error.message}`,
                    type: 'SYNTAX_CHECK_ERROR'
                });
            }
        }
    }

    checkVulnerabilities(filePath, content, lines) {
        this.criticalPatterns.forEach(patternObj => {
            const matches = content.match(patternObj.pattern);
            if (matches) {
                matches.forEach(match => {
                    const lineNumber = this.findLineNumber(content, match);
                    this.vulnerabilities.push({
                        file: filePath,
                        line: lineNumber,
                        type: patternObj.type,
                        severity: patternObj.severity,
                        match: match.trim(),
                        description: this.getVulnerabilityDescription(patternObj.type)
                    });
                });
            }
        });
    }

    checkCodeQuality(filePath, content, lines) {
        this.codeQualityPatterns.forEach(patternObj => {
            const matches = content.match(patternObj.pattern);
            if (matches) {
                matches.forEach(match => {
                    const lineNumber = this.findLineNumber(content, match);
                    this.warnings.push({
                        file: filePath,
                        line: lineNumber,
                        type: patternObj.type,
                        severity: patternObj.severity,
                        match: match.trim(),
                        description: this.getWarningDescription(patternObj.type)
                    });
                });
            }
        });
    }

    checkBlockchainSecurity(filePath, content, lines) {
        // Check for reentrancy vulnerabilities
        if (content.includes('transfer') && content.includes('call')) {
            const lineNumber = this.findLineNumber(content, 'transfer');
            this.vulnerabilities.push({
                file: filePath,
                line: lineNumber,
                type: 'REENTRANCY_RISK',
                severity: 'HIGH',
                match: 'transfer with call',
                description: 'Potential reentrancy vulnerability'
            });
        }
        
        // Check for overflow vulnerabilities
        if (content.includes('SafeMath') === false && content.includes('+') && filePath.includes('.sol')) {
            this.warnings.push({
                file: filePath,
                line: 1,
                type: 'OVERFLOW_RISK',
                severity: 'MEDIUM',
                match: 'arithmetic without SafeMath',
                description: 'Consider using SafeMath for arithmetic operations'
            });
        }
    }

    checkQuantumResistance(filePath, content, lines) {
        // Check for quantum-vulnerable algorithms
        const quantumVulnerable = [
            'RSA-1024', 'RSA-2048', 'ECDSA-P256', 'DH-1024'
        ];
        
        quantumVulnerable.forEach(algo => {
            if (content.includes(algo)) {
                const lineNumber = this.findLineNumber(content, algo);
                this.vulnerabilities.push({
                    file: filePath,
                    line: lineNumber,
                    type: 'QUANTUM_VULNERABLE',
                    severity: 'CRITICAL',
                    match: algo,
                    description: 'Algorithm vulnerable to quantum attacks'
                });
            }
        });
    }

    findLineNumber(content, searchString) {
        const lines = content.split('\n');
        for (let i = 0; i < lines.length; i++) {
            if (lines[i].includes(searchString)) {
                return i + 1;
            }
        }
        return 1;
    }

    getVulnerabilityDescription(type) {
        const descriptions = {
            'SQL_INJECTION': 'Potential SQL injection vulnerability',
            'COMMAND_INJECTION': 'Command injection vulnerability',
            'XSS': 'Cross-site scripting vulnerability',
            'HARDCODED_SECRET': 'Hardcoded credentials detected',
            'WEAK_CRYPTO': 'Weak cryptographic algorithm',
            'PATH_TRAVERSAL': 'Path traversal vulnerability',
            'CODE_INJECTION': 'Code injection vulnerability',
            'BLOCKCHAIN_VULN': 'Blockchain-specific vulnerability',
            'QUANTUM_VULN': 'Quantum-vulnerable cryptography'
        };
        return descriptions[type] || 'Security vulnerability detected';
    }

    getWarningDescription(type) {
        const descriptions = {
            'EMPTY_CATCH': 'Empty catch block - errors may be silently ignored',
            'INFO_LEAK': 'Potential information disclosure in logs',
            'POTENTIAL_MEMORY_LEAK': 'Potential memory leak - ensure proper cleanup',
            'DEPRECATED': 'Use of deprecated function'
        };
        return descriptions[type] || 'Code quality issue detected';
    }

    generateReport() {
        console.log('\n🛡️ SECURITY AUDIT RESULTS');
        console.log('=' .repeat(50));
        
        // Critical vulnerabilities
        const critical = this.vulnerabilities.filter(v => v.severity === 'CRITICAL');
        if (critical.length > 0) {
            console.log(`🚨 CRITICAL VULNERABILITIES: ${critical.length}`);
            critical.forEach(vuln => {
                console.log(`  ${vuln.file}:${vuln.line} - ${vuln.type}: ${vuln.description}`);
            });
        }
        
        // High severity vulnerabilities
        const high = this.vulnerabilities.filter(v => v.severity === 'HIGH');
        if (high.length > 0) {
            console.log(`⚠️  HIGH SEVERITY ISSUES: ${high.length}`);
            high.forEach(vuln => {
                console.log(`  ${vuln.file}:${vuln.line} - ${vuln.type}: ${vuln.description}`);
            });
        }
        
        // Medium severity vulnerabilities
        const medium = this.vulnerabilities.filter(v => v.severity === 'MEDIUM');
        if (medium.length > 0) {
            console.log(`📋 MEDIUM SEVERITY ISSUES: ${medium.length}`);
        }
        
        // Errors
        if (this.errors.length > 0) {
            console.log(`❌ ERRORS: ${this.errors.length}`);
            this.errors.forEach(error => {
                console.log(`  ${error.file} - ${error.type}: ${error.error}`);
            });
        }
        
        // Summary
        console.log('\n📊 SUMMARY:');
        console.log(`  Total Vulnerabilities: ${this.vulnerabilities.length}`);
        console.log(`  Critical: ${critical.length}`);
        console.log(`  High: ${high.length}`);
        console.log(`  Medium: ${medium.length}`);
        console.log(`  Errors: ${this.errors.length}`);
        console.log(`  Warnings: ${this.warnings.length}`);
        
        if (critical.length === 0 && high.length === 0 && this.errors.length === 0) {
            console.log('\n✅ NO CRITICAL ISSUES FOUND - SECURITY POSTURE IS STRONG');
        } else {
            console.log('\n⚠️  SECURITY ISSUES DETECTED - IMMEDIATE ATTENTION REQUIRED');
        }
        
        // Save detailed report
        const report = {
            timestamp: new Date().toISOString(),
            summary: {
                totalVulnerabilities: this.vulnerabilities.length,
                critical: critical.length,
                high: high.length,
                medium: medium.length,
                errors: this.errors.length,
                warnings: this.warnings.length
            },
            vulnerabilities: this.vulnerabilities,
            errors: this.errors,
            warnings: this.warnings
        };
        
        fs.writeFileSync('security_audit_report.json', JSON.stringify(report, null, 2));
        console.log('\n📄 Detailed report saved: security_audit_report.json');
    }
}

// Execute scan if run directly
if (require.main === module) {
    const checker = new VulnerabilityChecker();
    checker.scanProject().catch(console.error);
}

module.exports = VulnerabilityChecker;
